#!/usr/bin/env python3
"""
Human Refinement Interface

CLI tool for humans to review, refine, approve, or reject data product ideas
generated by the Learning Agent.

This provides the strategic human checkpoint before ideas move to evaluation.
"""

import argparse
import json
import sys
from pathlib import Path
from typing import List, Dict, Any

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))

from common.kafka_utils import (
    create_avro_consumer,
    create_avro_producer,
    produce_message
)
from common.schema_utils import get_schema_string


def load_ideas_from_files():
    """Load raw ideas from dry-run output files."""
    output_dir = Path(__file__).parent / "dry-run-output"
    ideas = []

    if not output_dir.exists():
        print("‚ö†Ô∏è  No dry-run-output directory found!")
        return ideas

    for idea_file in output_dir.glob("raw-idea-*.json"):
        with open(idea_file, 'r') as f:
            idea = json.load(f)
            ideas.append(idea)

    return ideas


def consume_all_raw_ideas(dry_run=False):
    """
    Consume all raw ideas from the agent-state-raw-ideas topic.
    In dry-run mode, reads from files instead of Kafka.
    """
    if dry_run:
        print("\nüìÇ Loading ideas from dry-run output files...")
        ideas = load_ideas_from_files()
        print(f"   ‚úÖ Loaded {len(ideas)} ideas")
        return ideas

    print("\nüì• Consuming raw ideas from Kafka...")

    schema_str = get_schema_string("raw-ideas")
    consumer, deserializer = create_avro_consumer(
        schema_str,
        group_id="human-refinement"
    )

    # Subscribe to topic
    consumer.subscribe(["agent-state-raw-ideas"])

    ideas = []
    try:
        # Poll for messages with timeout
        timeout_ms = 5000
        msg_count = 0

        while True:
            msg = consumer.poll(timeout=timeout_ms / 1000.0)

            if msg is None:
                break

            if msg.error():
                print(f"   ‚ö†Ô∏è  Consumer error: {msg.error()}")
                continue

            # Deserialize value
            value = deserializer(msg.value(), None)
            if value:
                ideas.append(value)
                msg_count += 1

        print(f"   ‚úÖ Consumed {msg_count} ideas")

    finally:
        consumer.close()

    return ideas


def display_idea(idea: Dict[str, Any], index: int):
    """Display an idea in a formatted way."""
    print(f"\n{'=' * 80}")
    print(f"IDEA #{index}: {idea['title']}")
    print(f"{'=' * 80}")
    print(f"\nüìå Domain: {idea['domain']}")
    print(f"üîñ Status: {idea['status']}")
    print(f"üéØ Complexity: {idea['estimated_complexity']}")
    print(f"üìä Confidence: {idea['confidence_score']:.2f}")
    print(f"\nüìù Description:")
    print(f"   {idea['description']}")
    print(f"\nüí° Reasoning:")
    print(f"   {idea['reasoning']}")
    print(f"\nüì¶ Related Topics ({len(idea['related_topics'])}):")
    for topic in idea['related_topics']:
        print(f"   - {topic}")
    print(f"\nüë• Potential Users:")
    for user in idea['potential_users']:
        print(f"   - {user}")
    print(f"\nüÜî Idea ID: {idea['idea_id']}")


def prompt_user_action(idea: Dict[str, Any]):
    """Prompt user for action on an idea."""
    print(f"\n{'‚îÄ' * 80}")
    print("Actions:")
    print("  [a] Approve - Move to evaluation")
    print("  [r] Reject - Mark as rejected")
    print("  [e] Edit - Modify idea details")
    print("  [s] Skip - Review later")
    print("  [q] Quit - Exit refinement")
    print(f"{'‚îÄ' * 80}")

    while True:
        action = input("\nYour choice: ").strip().lower()
        if action in ['a', 'r', 'e', 's', 'q']:
            return action
        print("Invalid choice. Please enter a, r, e, s, or q.")


def edit_idea(idea: Dict[str, Any]) -> Dict[str, Any]:
    """Allow user to edit idea details."""
    print("\n‚úèÔ∏è  Edit Idea (press Enter to keep current value)")

    # Title
    new_title = input(f"\nTitle [{idea['title']}]: ").strip()
    if new_title:
        idea['title'] = new_title

    # Description
    new_description = input(f"\nDescription [{idea['description'][:50]}...]: ").strip()
    if new_description:
        idea['description'] = new_description

    # Domain
    new_domain = input(f"\nDomain [{idea['domain']}]: ").strip()
    if new_domain:
        idea['domain'] = new_domain

    # Complexity
    print(f"\nComplexity [{idea['estimated_complexity']}]")
    print("  Options: LOW, MEDIUM, HIGH, VERY_HIGH")
    new_complexity = input("  Choice: ").strip().upper()
    if new_complexity in ['LOW', 'MEDIUM', 'HIGH', 'VERY_HIGH']:
        idea['estimated_complexity'] = new_complexity

    # Topics (comma-separated)
    print(f"\nRelated Topics (current: {len(idea['related_topics'])})")
    print(f"  {', '.join(idea['related_topics'][:3])}...")
    new_topics = input("  Add/replace (comma-separated): ").strip()
    if new_topics:
        idea['related_topics'] = [t.strip() for t in new_topics.split(',')]

    print("\n‚úÖ Idea updated!")
    return idea


def refine_ideas(ideas: List[Dict[str, Any]], dry_run=False):
    """Main refinement loop."""
    print(f"\n{'=' * 80}")
    print("HUMAN REFINEMENT INTERFACE")
    print(f"{'=' * 80}")
    print(f"\nüìä {len(ideas)} ideas to review")

    if not ideas:
        print("\n‚ö†Ô∏è  No ideas to review!")
        return

    approved = []
    rejected = []
    modified = []

    for i, idea in enumerate(ideas, 1):
        # Skip if already processed
        if idea['status'] in ['APPROVED', 'REJECTED']:
            continue

        display_idea(idea, i)
        action = prompt_user_action(idea)

        if action == 'a':
            # Approve
            idea['status'] = 'APPROVED'
            approved.append(idea)
            print("\n‚úÖ Idea APPROVED - will proceed to evaluation")

        elif action == 'r':
            # Reject
            idea['status'] = 'REJECTED'
            rejected.append(idea)
            reason = input("\nRejection reason (optional): ").strip()
            if reason:
                idea['rejection_reason'] = reason
            print("\n‚ùå Idea REJECTED")

        elif action == 'e':
            # Edit
            idea = edit_idea(idea)
            idea['status'] = 'REFINED'
            modified.append(idea)

            # Ask if they want to approve after editing
            approve_now = input("\nApprove this idea now? [y/N]: ").strip().lower()
            if approve_now == 'y':
                idea['status'] = 'APPROVED'
                approved.append(idea)
                print("\n‚úÖ Idea APPROVED after refinement")
            else:
                print("\nüìù Idea REFINED - marked for later review")

        elif action == 's':
            # Skip
            print("\n‚è≠Ô∏è  Skipped - will remain in RAW status")
            continue

        elif action == 'q':
            # Quit
            print("\nüëã Exiting refinement...")
            break

        # Save changes back to Kafka or file
        if action in ['a', 'r', 'e'] and idea['status'] != 'RAW':
            save_idea(idea, dry_run=dry_run)

    # Summary
    print(f"\n{'=' * 80}")
    print("REFINEMENT SUMMARY")
    print(f"{'=' * 80}")
    print(f"‚úÖ Approved: {len(approved)}")
    print(f"‚ùå Rejected: {len(rejected)}")
    print(f"‚úèÔ∏è  Modified: {len(modified)}")
    print(f"üìù Remaining: {len([i for i in ideas if i['status'] == 'RAW'])}")

    if approved:
        print("\nüéØ Approved Ideas:")
        for idea in approved:
            print(f"   - {idea['title']} ({idea['domain']})")


def save_idea(idea: Dict[str, Any], dry_run=False):
    """Save updated idea back to Kafka or file."""
    if dry_run:
        # Save to file
        output_dir = Path(__file__).parent / "dry-run-output"
        output_dir.mkdir(exist_ok=True)
        output_file = output_dir / f"raw-idea-{idea['idea_id']}.json"

        with open(output_file, 'w') as f:
            json.dump(idea, f, indent=2)

        print(f"   üíæ Saved to {output_file.name}")
    else:
        # Publish to Kafka
        try:
            schema_str = get_schema_string("raw-ideas")
            producer, serializer = create_avro_producer(schema_str)

            produce_message(
                producer=producer,
                serializer=serializer,
                topic="agent-state-raw-ideas",
                key=idea['idea_id'],
                value=idea
            )

            print(f"   ‚úÖ Updated in Kafka")

        except Exception as e:
            print(f"   ‚ùå Failed to update: {e}")


def run_human_refinement(dry_run=False):
    """Main entry point for human refinement."""
    ideas = consume_all_raw_ideas(dry_run=dry_run)

    if not ideas:
        print("\n‚ö†Ô∏è  No ideas found to review!")
        print("   Run the Learning Agent first to generate ideas.")
        return

    refine_ideas(ideas, dry_run=dry_run)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Human Refinement Interface - Review and refine AI-generated data product ideas"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Dry run mode: read from files instead of Kafka"
    )
    args = parser.parse_args()

    run_human_refinement(dry_run=args.dry_run)
